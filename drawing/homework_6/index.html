<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <title>HTML Canvas</title>
    <link rel="stylesheet" href="styles.css">
    <style>
      canvas {background-color: lightgray;} /* change or remove this color */
    </style>
  </head>

  <body>
    <div id="frame">
      <canvas id="c1" width="600" height="400"></canvas>
      <canvas id="c2" width="600" height="400"></canvas>
    </div>
  </body>
  <script>
      /* At least one drawing should include a custom shape drawn with path methods of the canvas API.
        At least one drawing should include a photographic image or video whose pixel data is 
        manipulated with the ImageData object. 
        Each of the canvas drawings should be visibly animated with the window objectâ€™s requestAnimationFrame() method.
      */

      //declare dom elements
      const frame = document.getElementById("frame");
      const canvas1 = document.getElementById("c1"); const canvas2 = document.getElementById("c2"); //get element
      const context1 = canvas1.getContext('2d'); const context2 = canvas2.getContext('2d'); //get context
      //make image
      const imageFrame = document.createElement("div");
      const image = document.createElement("img");
      imageFrame.style.display = "None";
      image.alt = "Photo of geometric fractal";
      image.src = "icon/scene.jpeg";
      imageFrame.appendChild(image)
      document.querySelector("body").appendChild(imageFrame)

      const imageData = document.querySelector("img")

      let width;
      let height;

      let pixelScale = window.devicePixelRatio; //set pixel ratio

      function setup() {
        width = window.innerWidth/2;
        height = window.innerHeight;

        canvas1.style.width = width; canvas2.style.width = width; //set width to scale
        canvas1.style.height = height; canvas2.style.height = height; //set height to scale

        context1.scale(pixelScale, pixelScale); context2.scale(pixelScale, pixelScale); //scale context
      }

      let red = {"shift" : 0, "polarity": -1};
      let green = {"shift" : 1, "polarity": 1};
      let factor = 10; // 

      function canvas_draw1() {
        //At least one drawing should include a photographic image or video whose pixel data is 
        // manipulated with the ImageData object.

        //based quite a bit from the example. https://i6.cims.nyu.edu/~jc3436/drawing/canvas/animated-pixel-processing-2.html
        //I wanted to recreate the violent colors I saw at EDM concerts
        scale = {"drawScale": 3, "imageScale": 4}
        dimensions = {"width":  ((canvas1.width/pixelScale)/2)/(scale.imageScale*pixelScale), "height": ((canvas1.height/pixelScale)/2)/(scale.imageScale*pixelScale)}
        
        // context1.drawImage(imageData, 0, 0, dimensions.width*2, dimensions.height*2);

        for (let i = 0; i<scale.drawScale-1; i++){ // horizontal
          for (let j = 0; j<scale.drawScale-1; j++){ // vertical
            context1.drawImage(imageData, dimensions.width*i, dimensions.height*j, dimensions.width, dimensions.height);
          }
        }
        let pixels = context1.getImageData(0, 0, canvas1.width, canvas1.height);
        let data = pixels.data;

        context1.clearRect(0, 0, canvas1.width, canvas1.height); //clear canvas

        red.shift += red.polarity * factor;
        green.shift += green.polarity * factor;

        // locate and shift pixels
        for (let y = 0; y < pixels.height/6; y++) {
          for (let x = 0; x < pixels.width/6; x++) {
            let index = (x + y * pixels.width) * 4; // index position of every pixel
            r = data[(index + 0)] + Math.floor(Math.random()*95)+40; // shift red channel
            g = data[(index + 1)] + Math.floor(Math.random()*58)+80; // shift green channel
            b = data[(index + 2)]+ Math.floor(Math.random()*120)+60; //shift blue 
            a = Math.random()*9
            // apply rgb as fill color to subsequent shapes
            context1.fillStyle = `rgba(${r},${g},${b},${a})`;

            context1.save();
            // adjust position of circles
            // context1.translate(scale.imageScale / 2, scale.imageScale / 2); // center in frame
            context1.beginPath();
            // draw circle at appropriate location
            context1.arc(x * scale.imageScale, y * scale.imageScale, scale.imageScale / 2, 0.25*Math.PI, Math.PI * 2);
            context1.fill();
            context1.restore();
          }
        }
        requestAnimationFrame(canvas_draw1) //redraw canvas
      }
    
      let degree = 0
      let numSides = 4;
      let interval = 1;
      let r, g, b, a;
      let counter = 10;

      function canvas_draw2() {
        //recursive function, constructs each line segment until total number of sides equals how many constructed
        function drawShape(x,y,sides,count = 0){
          if (sides==count){ context2.closePath(); context2.fill(); return}; //draw full shape
          context2.lineTo(x+50*count,y);
          context2.translate(x/sides,y/sides);
          context2.rotate((2**sides)*Math.PI/180); //initially 360
          count+=1
          drawShape(x,y,sides,count) //call it again
        }

        if(counter>=5){ // change to differentiate shape
          // At least one drawing should include a custom shape drawn with path methods of the canvas API.
          context2.save()
          context2.fillStyle= "black";
          context2.fillRect(0, 0, canvas2.width, canvas2.height); //clear canvas
          context2.restore()
          /*
          // r = setInterval(() => {return Math.floor(Math.random()*95)+110}, 1000);
          // g = setInterval(() => {return Math.floor(Math.random()*85)+105}, 1000);
          // b = setInterval(() => {return Math.floor(Math.random()*115)+100}, 1000);
          // super inefficient, need to take another stab at this

          Look at this - Scrapped
          var gradient = context2.createRadialGradient(110,90,30, 100,100,70);

          // Add three color stops
          gradient.addColorStop(0, 'red');
          gradient.addColorStop(.9, 'pink');
          gradient.addColorStop(1, 'white');
          */

          r = Math.floor(Math.random()*95)+110
          g = Math.floor(Math.random()*85)+105
          b = Math.floor(Math.random()*115)+100
          
          context2.beginPath();
          // context2.translate(canvas2.width/4,canvas2.height/4) //center of canvas
          context2.moveTo(-100,0)
          // context2.rotate(90*Math.PI/180)

          if(numSides >= 7){
            interval *=-1
          }else if(numSides <4){
            interval *=-1
          }
          
          let start = 25;
          let end = 25;
          
          context2.save() //save current position
          // context2.translate(-1*start,-1*end)
          context2.moveTo(canvas2.width/4,canvas2.height/4) //first translation
          //construct the shape
          for (let i = 0; i<Math.floor(Math.random()*90)+10; i++){
            context2.save()
            context2.translate(canvas2.width/4,canvas2.height/4)
            context2.rotate((36*i)*Math.PI/180)
            context2.translate(-1*start,-1*end)
            context2.fillStyle = `rgba(${r},${g},${b},${(Math.random()*2)/2+0.2})`;
            drawShape(start,end,numSides);
            context2.restore()
          }
          numSides+=interval //increment shape interval
            //randomize line width and stroke
          context2.lineWidth = Math.floor(Math.random()) + 2
          context2.strokeStyle = `rgba(${200},${50},${140},${Math.random()*0.8+0.1})`;
          context2.stroke()
          context2.restore() //will keep translating if i dont restore

          counter=0;
        }else{ 
          counter+=1
        }
        //counter
        requestAnimationFrame(canvas_draw2) //dont use setTimeout
        // console.log(requestAnimationFrame(canvas_draw2))
      }

      window.addEventListener('load', () => { setup(); canvas_draw1(); canvas_draw2(); });
      window.addEventListener('resize', () => { setup(); canvas_draw1(); canvas_draw2() });
  </script>
</html>
